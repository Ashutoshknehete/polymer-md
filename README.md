This Python package is divided into three sections namely structure, simtools, and analysis, with each containing a list of Python scripts written in an object oriented fashion. 

structure

systemspec.py: This code implements an object-oriented framework for constructing and describing molecular systems composed of monatomic and polymeric species. At the lowest level, MonomerSpec and BlockSpec define the chemical identity, length, and particle types of monomers and polymer blocks, while the abstract Species base class enforces a common interface (label, length, particletypes) for all molecular species. Concrete species include MonatomicMoleculeSpec for single-bead monoatomic molecules, LinearPolymerSpec for block copolymers with specified sequential connectivity, and BranchedPolymerSpec for complex architectures such as star, grafted, mikto-arm, and custom branched polymers. These polymer classes automatically generate particle types, bonds, bond types, angles, and angle types from the specified topology, explicitly handling junction nodes, free ends, and directionality of connectivity. At the system level, Component represents a population of identical molecules, Box defines the simulation domain, and System aggregates all components into a complete molecular system. The System class provides utilities to compute global particle counts and types, molecule- and block-level particle indices, bond and angle lists (both globally and per molecule), junction identification, and adjacency (bond) graphs, while maintaining consistent particle ordering for both linear and branched chains. 

systemgen.py: This module provides utilities to generate initial particle coordinates and simulation snapshots for molecular systems defined using the system specification framework described above. It implements Monte Carloâ€“based random walk algorithms to build polymer conformations at the block level (mc_chain_walk) and specialized connection routines for linear polymer chains (connect_chains_linear), star polymers (connect_chains_star), and grafted polymers (connect_chains_graft), ensuring minimal backfolding of chains through geometric acceptance criteria. High-level walker functions (walk_linearPolymer, walk_starPolymer, walk_graftPolymer) assemble full polymer coordinates from their block specifications, while walkComponent handles repeated instances of a given species. At the system level, the code places molecules randomly within the simulation box or predefined spatial regions using placeComponent, applies periodic wrapping with wrap_coords, and assembles full-system coordinate arrays via systemCoordsRandom or systemCoordsBoxRegions. Helper functions (getParticleTypes, getBondTypes, getAngleTypes) extract particle, bond, and angle types and their corresponding indices directly from the system specification. Finally, build_snapshot integrates all structural information: box dimensions, particle positions, types, bonds, and angles into a HOOMD-compatible GSD snapshot, providing a complete, ready-to-simulate representation of the molecular system.
simtools

simroutines.py: This code is a modular collection of functions for managing, running, and logging molecular dynamics simulations of polymer systems interacting with LJ and FENE potentials in HOOMD-blue. The initial setup functions like setup_LJ_FENE establish the simulation environment by applying force fields (LJ and FENE), integrators, and logging utilities. They also handle optional outputs such as trajectories, snapshots, and detailed logs, making them foundational to all subsequent routines. run_GAUSSIAN_FENE provides a specialized integration routine for overlap removal using a Gaussian pair potential with ramped energetic pre-factors. Functions like remove_overlaps and relax_overlaps_AB focus on preparing physically reasonable starting configurations. remove_overlaps uses the soft Gaussian FENE potentials to resolve particle overlaps, while relax_overlaps_AB use the NVE ensemble and a capped displacement integrator with appropriate interactions to relax the configurations. These functions are critical for preventing numerical instabilities before equilibration. Equilibration functions such as equilibrate_AB, equilibrate_npt, simulate_npat instantiate simulations through Langevin or NPT/NPAT dynamics. They differ in the type of ensemble and integrator used and are central for preparing the system for meaningful production runs. The production function executes equilibrium simulation under controlled temperature and optionally zeroes net momentum to remove bulk drift. The framework also includes robust logging and analysis utilities. basic_logger and add_table_log track thermodynamic and global simulation properties. The functions add_filtered_thermo and run_filtered_thermo enable spatially resolved thermodynamic monitoring along a chosen axis, outputting both GSD logs and edge data. Snapshot and trajectory writers (add_write_state and add_write_trajectory) allow capturing system states at specific times or periodically. 

analysis

trajtools.py: This module provides a comprehensive suite of analysis functions. The functions are designed to extract structural, spatial, and thermodynamic information from simulation frames or trajectories. At the core, getBondedClusters identifies bonded molecular clusters using neighbor lists, enabling further calculations of internal distances and conformational properties. Density functions (density_system, density_1D_monomers, density_1D_species, density_1D_lowest) quantify the number density or volume fraction along a specific axis or in full 3D, allowing characterization of phase separation or spatial distributions of monomers and species. Several functions target polymer conformational analysis: internaldistances_all and internaldistances_species compute mean-squared internal distances within homopolymer or copolymer chains species; radius_gyration, molecule_stretching, and molecule_stretching_monomer measure overall and directional radii of gyration, providing insights into copolymer shape, and anisometry. For block copolymers, lineardistancesfromjunctions and endToEndVectors compute distance statistics from junction points and end-to-end vectors, useful for understanding chain orientation and stretching behavior. Spatial organization of junctions on interfaces is addressed with junction_RDF, junction_locations, junction_RDF_accumulate, and junction_density_smeared functions, which compute radial distribution functions, positions, or smoothed density fields of junctions across the system or accumulated over multiple frames. Volume fraction fields in 1D or 3D are computed via volfrac_fields and volfrac_fields_species, supporting the computation of overlap integrals (overlap_integral, overlap_integral_species, overlap_integral_species_normalized) to quantify mixing between homopolymer and copolymer species. Finally, interfacial properties are analyzed with interfacial_tension_IK and interfacial_tension_global, which estimate interfacial tension from local or global pressure tensors. Utility functions like ensemble_average_log allow averaging of logged simulation data across frames. 

statistics.py: This module provides tools for analyzing time-correlated simulation data and extracting statistically significant data. The core function, estimate_autocorrelation_time, uses block averaging and linear regression to estimate the autocorrelation time of a time series or multi-dimensional property, capturing how quickly the system decorrelates. Building on this, num_independent_samples computes the effective number of independent samples by dividing the total number of samples by twice the autocorrelation time, providing a corrected measure of sample size for statistical analysis. The estimator_variance function uses this information to calculate the variance of the mean for finite-length trajectories, accounting for correlations and yielding a robust estimate of uncertainty. Finally, get_independent_samples produces a reduced set of independent samples by averaging over blocks corresponding to the autocorrelation time, enabling subsequent analyses to be performed on statistically independent data. 
